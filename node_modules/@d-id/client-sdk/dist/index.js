var ke = Object.defineProperty;
var De = (e, t, n) => t in e ? ke(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var Z = (e, t, n) => De(e, typeof t != "symbol" ? t + "" : t, n);
class te extends Error {
  constructor({ kind: n, description: r, error: s }) {
    super(JSON.stringify({ kind: n, description: r }));
    Z(this, "kind");
    Z(this, "description");
    Z(this, "error");
    this.kind = n, this.description = r, this.error = s;
  }
}
class Ce extends te {
  constructor(t, n) {
    super({
      kind: "ChatCreationFailed",
      description: `Failed to create ${n ? "persistent" : ""} chat, mode: ${t}`
    });
  }
}
class Re extends te {
  constructor(t) {
    super({ kind: "ChatModeDowngraded", description: `Chat mode downgraded to ${t}` });
  }
}
class H extends te {
  constructor(n, r) {
    super({ kind: "ValidationError", description: n });
    Z(this, "key");
    this.key = r;
  }
}
class Se extends te {
  constructor(t) {
    super({ kind: "WSError", description: t });
  }
}
var Ie = /* @__PURE__ */ ((e) => (e.TRIAL = "trial", e.BASIC = "basic", e.ENTERPRISE = "enterprise", e.LITE = "lite", e.ADVANCED = "advanced", e))(Ie || {}), Ee = /* @__PURE__ */ ((e) => (e.TRIAL = "deid-trial", e.PRO = "deid-pro", e.ENTERPRISE = "deid-enterprise", e.LITE = "deid-lite", e.ADVANCED = "deid-advanced", e.BUILD = "deid-api-build", e.LAUNCH = "deid-api-launch", e.SCALE = "deid-api-scale", e))(Ee || {}), Me = /* @__PURE__ */ ((e) => (e.Created = "created", e.Started = "started", e.Done = "done", e.Error = "error", e.Rejected = "rejected", e.Ready = "ready", e))(Me || {}), _e = /* @__PURE__ */ ((e) => (e.Unrated = "Unrated", e.Positive = "Positive", e.Negative = "Negative", e))(_e || {}), E = /* @__PURE__ */ ((e) => (e.Functional = "Functional", e.TextOnly = "TextOnly", e.Maintenance = "Maintenance", e.Playground = "Playground", e.DirectPlayback = "DirectPlayback", e.Off = "Off", e))(E || {}), q = /* @__PURE__ */ ((e) => (e.Embed = "embed", e.Query = "query", e.Partial = "partial", e.Answer = "answer", e.Complete = "done", e))(q || {}), Te = /* @__PURE__ */ ((e) => (e.KnowledgeProcessing = "knowledge/processing", e.KnowledgeIndexing = "knowledge/indexing", e.KnowledgeFailed = "knowledge/error", e.KnowledgeDone = "knowledge/done", e))(Te || {}), je = /* @__PURE__ */ ((e) => (e.Knowledge = "knowledge", e.Document = "document", e.Record = "record", e))(je || {}), Ae = /* @__PURE__ */ ((e) => (e.Pdf = "pdf", e.Text = "text", e.Html = "html", e.Word = "word", e.Json = "json", e.Markdown = "markdown", e.Csv = "csv", e.Excel = "excel", e.Powerpoint = "powerpoint", e.Archive = "archive", e.Image = "image", e.Audio = "audio", e.Video = "video", e))(Ae || {}), de = /* @__PURE__ */ ((e) => (e.Clip = "clip", e.Talk = "talk", e.Expressive = "expressive", e))(de || {});
const jt = (e) => {
  switch (e) {
    case "clip":
      return "clip";
    case "talk":
      return "talk";
    default:
      throw new Error(`Unknown video type: ${e}`);
  }
};
var w = /* @__PURE__ */ ((e) => (e.Start = "START", e.Stop = "STOP", e))(w || {}), G = /* @__PURE__ */ ((e) => (e.Strong = "STRONG", e.Weak = "WEAK", e.Unknown = "UNKNOWN", e))(G || {}), O = /* @__PURE__ */ ((e) => (e.Idle = "IDLE", e.Talking = "TALKING", e))(O || {}), P = /* @__PURE__ */ ((e) => (e.ChatAnswer = "chat/answer", e.ChatPartial = "chat/partial", e.StreamDone = "stream/done", e.StreamStarted = "stream/started", e.StreamFailed = "stream/error", e.StreamReady = "stream/ready", e.StreamCreated = "stream/created", e.StreamInterrupt = "stream/interrupt", e.StreamVideoCreated = "stream-video/started", e.StreamVideoDone = "stream-video/done", e.StreamVideoError = "stream-video/error", e.StreamVideoRejected = "stream-video/rejected", e))(P || {}), R = /* @__PURE__ */ ((e) => (e.New = "new", e.Fail = "fail", e.Connected = "connected", e.Connecting = "connecting", e.Closed = "closed", e.Completed = "completed", e.Disconnected = "disconnected", e))(R || {}), J = /* @__PURE__ */ ((e) => (e.Legacy = "legacy", e.Fluent = "fluent", e))(J || {}), be = /* @__PURE__ */ ((e) => (e.Livekit = "livekit", e))(be || {}), Pe = /* @__PURE__ */ ((e) => (e.Amazon = "amazon", e.Microsoft = "microsoft", e.Afflorithmics = "afflorithmics", e.Elevenlabs = "elevenlabs", e))(Pe || {}), Le = /* @__PURE__ */ ((e) => (e.Public = "public", e.Premium = "premium", e.Private = "private", e))(Le || {});
const Be = 45 * 1e3, $e = "X-Playground-Chat", ee = "https://api.d-id.com", xe = "wss://notifications.d-id.com", ze = "79f81a83a67430be2bc0fd61042b8faa", le = (e) => new Promise((t) => setTimeout(t, e)), V = (e = 16) => {
  const t = new Uint8Array(e);
  return window.crypto.getRandomValues(t), Array.from(t, (n) => n.toString(16).padStart(2, "0")).join("").slice(0, 13);
}, Fe = (e) => [E.TextOnly, E.Playground, E.Maintenance].includes(e), ue = (e) => e && [E.DirectPlayback, E.Off].includes(e);
function Ne(e, t) {
  let n;
  return {
    promise: new Promise((s, o) => {
      n = setTimeout(() => o(new Error(t)), e);
    }),
    clear: () => clearTimeout(n)
  };
}
async function ne(e, t) {
  const n = {
    limit: (t == null ? void 0 : t.limit) ?? 3,
    delayMs: (t == null ? void 0 : t.delayMs) ?? 0,
    timeout: (t == null ? void 0 : t.timeout) ?? 3e4,
    timeoutErrorMessage: (t == null ? void 0 : t.timeoutErrorMessage) || "Timeout error",
    shouldRetryFn: (t == null ? void 0 : t.shouldRetryFn) ?? (() => !0),
    onRetry: (t == null ? void 0 : t.onRetry) ?? (() => {
    })
  };
  let r;
  for (let s = 1; s <= n.limit; s++)
    try {
      if (!n.timeout)
        return await e();
      const { promise: o, clear: c } = Ne(n.timeout, n.timeoutErrorMessage), a = e().finally(c);
      return await Promise.race([a, o]);
    } catch (o) {
      if (r = o, !n.shouldRetryFn(o) || s >= n.limit)
        throw o;
      await le(n.delayMs), n.onRetry(o);
    }
  throw r;
}
function fe() {
  let e = window.localStorage.getItem("did_external_key_id");
  if (!e) {
    let t = V();
    window.localStorage.setItem("did_external_key_id", t), e = t;
  }
  return e;
}
let Je = V();
function me(e) {
  if (e.type === "bearer")
    return `Bearer ${e.token}`;
  if (e.type === "basic")
    return `Basic ${btoa(`${e.username}:${e.password}`)}`;
  if (e.type === "key")
    return `Client-Key ${e.clientKey}.${fe()}_${Je}`;
  throw new Error(`Unknown auth type: ${e}`);
}
const We = (e) => ne(e, {
  limit: 3,
  delayMs: 1e3,
  timeout: 0,
  shouldRetryFn: (t) => t.status === 429
});
function ge(e, t = ee, n) {
  const r = async (s, o) => {
    const { skipErrorHandler: c, ...a } = o || {}, i = await We(
      () => fetch(t + (s != null && s.startsWith("/") ? s : `/${s}`), {
        ...a,
        headers: {
          ...a.headers,
          Authorization: me(e),
          "Content-Type": "application/json"
        }
      })
    );
    if (!i.ok) {
      let d = await i.text().catch(() => `Failed to fetch with status ${i.status}`);
      const l = new Error(d);
      throw n && !c && n(l, { url: s, options: a, headers: i.headers }), l;
    }
    return i.json();
  };
  return {
    get(s, o) {
      return r(s, { ...o, method: "GET" });
    },
    post(s, o, c) {
      return r(s, { ...c, body: JSON.stringify(o), method: "POST" });
    },
    delete(s, o, c) {
      return r(s, { ...c, body: JSON.stringify(o), method: "DELETE" });
    },
    patch(s, o, c) {
      return r(s, { ...c, body: JSON.stringify(o), method: "PATCH" });
    }
  };
}
function he(e, t = ee, n) {
  const r = ge(e, `${t}/agents`, n);
  return {
    create(s, o) {
      return r.post("/", s, o);
    },
    getAgents(s, o) {
      return r.get(`/${s ? `?tag=${s}` : ""}`, o).then((c) => c ?? []);
    },
    getById(s, o) {
      return r.get(`/${s}`, o);
    },
    delete(s, o) {
      return r.delete(`/${s}`, void 0, o);
    },
    update(s, o, c) {
      return r.patch(`/${s}`, o, c);
    },
    newChat(s, o, c) {
      return r.post(`/${s}/chat`, o, c);
    },
    chat(s, o, c, a) {
      return r.post(`/${s}/chat/${o}`, c, a);
    },
    createRating(s, o, c, a) {
      return r.post(`/${s}/chat/${o}/ratings`, c, a);
    },
    updateRating(s, o, c, a, i) {
      return r.patch(`/${s}/chat/${o}/ratings/${c}`, a, i);
    },
    deleteRating(s, o, c, a) {
      return r.delete(`/${s}/chat/${o}/ratings/${c}`, a);
    },
    getSTTToken(s, o) {
      return r.get(`/${s}/stt-token`, o);
    }
  };
}
const we = (e) => e.type === "clip" && e.presenter_id.startsWith("v2_") ? "clip_v2" : e.type;
function Ue(e) {
  var s, o, c, a;
  const t = () => /Mobi|Android/i.test(navigator.userAgent) ? "Mobile" : "Desktop", n = () => {
    const i = navigator.platform;
    return i.toLowerCase().includes("win") ? "Windows" : i.toLowerCase().includes("mac") ? "Mac OS X" : i.toLowerCase().includes("linux") ? "Linux" : "Unknown";
  }, r = e.presenter;
  return {
    $os: `${n()}`,
    isMobile: `${t() == "Mobile"}`,
    browser: navigator.userAgent,
    origin: window.location.origin,
    agentType: we(r),
    agentVoice: {
      voiceId: (o = (s = e.presenter) == null ? void 0 : s.voice) == null ? void 0 : o.voice_id,
      provider: (a = (c = e.presenter) == null ? void 0 : c.voice) == null ? void 0 : a.type
    }
  };
}
function Ke(e) {
  var n, r, s, o, c, a;
  const t = (n = e.llm) == null ? void 0 : n.prompt_customization;
  return {
    agentType: we(e.presenter),
    owner_id: e.owner_id ?? "",
    promptVersion: (r = e.llm) == null ? void 0 : r.prompt_version,
    behavior: {
      role: t == null ? void 0 : t.role,
      personality: t == null ? void 0 : t.personality,
      instructions: (s = e.llm) == null ? void 0 : s.instructions
    },
    temperature: (o = e.llm) == null ? void 0 : o.temperature,
    knowledgeSource: t == null ? void 0 : t.knowledge_source,
    starterQuestionsCount: (a = (c = e.knowledge) == null ? void 0 : c.starter_message) == null ? void 0 : a.length,
    topicsToAvoid: t == null ? void 0 : t.topics_to_avoid,
    maxResponseLength: t == null ? void 0 : t.max_response_length,
    agentId: e.id,
    access: e.access,
    name: e.preview_name,
    ...e.access === "public" ? { from: "agent-template" } : {}
  };
}
const He = (e) => e.reduce((t, n) => t + n, 0), se = (e) => He(e) / e.length;
function qe(e, t, n) {
  var i, d, l;
  const { event: r, ...s } = e, { template: o } = (t == null ? void 0 : t.llm) || {}, { language: c } = ((i = t == null ? void 0 : t.presenter) == null ? void 0 : i.voice) || {};
  return {
    ...s,
    llm: { ...s.llm, template: o },
    script: { ...s.script, provider: { ...(d = s == null ? void 0 : s.script) == null ? void 0 : d.provider, language: c } },
    stitch: (t == null ? void 0 : t.presenter.type) === "talk" ? (l = t == null ? void 0 : t.presenter) == null ? void 0 : l.stitch : void 0,
    ...n
  };
}
let re = {};
const Ve = "https://api-js.mixpanel.com/track/?verbose=1&ip=1";
function Oe(e) {
  const t = window != null && window.hasOwnProperty("DID_AGENTS_API") ? "agents-ui" : "agents-sdk";
  return {
    token: e.token || "testKey",
    distinct_id: e.distinctId || fe(),
    agentId: e.agentId,
    additionalProperties: {
      id: e.distinctId,
      ...e.mixpanelAdditionalProperties || {}
    },
    isEnabled: e.isEnabled ?? !0,
    getRandom: V,
    enrich(n) {
      this.additionalProperties = { ...this.additionalProperties, ...n };
    },
    async track(n, r) {
      if (!this.isEnabled)
        return Promise.resolve();
      const { audioPath: s, ...o } = r || {}, c = {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: new URLSearchParams({
          data: JSON.stringify([
            {
              event: n,
              properties: {
                ...this.additionalProperties,
                ...o,
                agentId: this.agentId,
                source: t,
                token: this.token,
                time: Date.now(),
                $insert_id: this.getRandom(),
                origin: window.location.href,
                "Screen Height": window.screen.height || window.innerWidth,
                "Screen Width": window.screen.width || window.innerHeight,
                "User Agent": navigator.userAgent
              }
            }
          ])
        })
      };
      try {
        return await fetch(Ve, c).then((a) => a.json());
      } catch (a) {
        return console.error(a);
      }
    },
    linkTrack(n, r, s, o) {
      re[n] || (re[n] = { events: {}, resolvedDependencies: [] }), o.includes(s) || o.push(s);
      const c = re[n];
      if (c.events[s] = { props: r }, c.resolvedDependencies.push(s), o.every(
        (i) => c.resolvedDependencies.includes(i)
      )) {
        const i = o.reduce((d, l) => c.events[l] ? { ...d, ...c.events[l].props } : d, {});
        this.track(n, i), c.resolvedDependencies = c.resolvedDependencies.filter(
          (d) => !o.includes(d)
        ), o.forEach((d) => {
          delete c.events[d];
        });
      }
    }
  };
}
function pe() {
  let e = 0;
  return {
    reset: () => e = 0,
    update: () => e = Date.now(),
    get: (t = !1) => t ? Date.now() - e : e
  };
}
const $ = pe(), ae = pe();
function ye(e) {
  return e === E.Playground ? { headers: { [$e]: "true" } } : {};
}
async function ve(e, t, n, r, s = !1, o) {
  try {
    return !o && !ue(r) && (o = await t.newChat(e.id, { persist: s }, ye(r)), n.track("agent-chat", {
      event: "created",
      chatId: o.id,
      mode: r
    })), { chat: o, chatMode: (o == null ? void 0 : o.chat_mode) ?? r };
  } catch (c) {
    try {
      const a = JSON.parse(c.message);
      if ((a == null ? void 0 : a.kind) === "InsufficientCreditsError")
        throw new Error("InsufficientCreditsError");
    } catch (a) {
      console.error("Error parsing the error message:", a);
    }
    throw new Error("Cannot create new chat");
  }
}
function Xe(e) {
  return e && e.length > 0 ? e : [];
}
function Ye(e, t, n) {
  if (!e)
    throw new Error("Please connect to the agent first");
  if (!e.interruptAvailable)
    throw new Error("Interrupt is not enabled for this stream");
  if (t !== J.Fluent)
    throw new Error("Interrupt only available for Fluent streams");
  if (!n)
    throw new Error("No active video to interrupt");
}
async function Qe(e, t) {
  const n = {
    type: P.StreamInterrupt,
    videoId: t,
    timestamp: Date.now()
  };
  e.sendDataChannelMessage(JSON.stringify(n));
}
function Ze(e) {
  return new Promise((t, n) => {
    const { callbacks: r, host: s, auth: o } = e, { onMessage: c = null, onOpen: a = null, onClose: i = null, onError: d = null } = r || {}, l = new WebSocket(`${s}?authorization=${me(o)}`);
    l.onmessage = c, l.onclose = i, l.onerror = (y) => {
      console.error(y), d == null || d("Websocket failed to connect", y), n(y);
    }, l.onopen = (y) => {
      a == null || a(y), t(l);
    };
  });
}
async function Ge(e) {
  const { retries: t = 1 } = e;
  let n = null;
  for (let r = 0; (n == null ? void 0 : n.readyState) !== WebSocket.OPEN; r++)
    try {
      n = await Ze(e);
    } catch (s) {
      if (r === t)
        throw s;
      await le(r * 500);
    }
  return n;
}
async function et(e, t, n) {
  const r = n != null && n.onMessage ? [n.onMessage] : [], s = await Ge({
    auth: e,
    host: t,
    callbacks: {
      onError: (o) => {
        var c;
        return (c = n.onError) == null ? void 0 : c.call(n, new Se(o));
      },
      onMessage(o) {
        const c = JSON.parse(o.data);
        r.forEach((a) => a(c.event, c));
      }
    }
  });
  return {
    socket: s,
    disconnect: () => s.close(),
    subscribeToEvents: (o) => r.push(o)
  };
}
function tt(e) {
  if (e.answer !== void 0)
    return e.answer;
  let t = 0, n = "";
  for (; t in e; )
    n += e[t++];
  return n;
}
function rt(e, t, n, r, s) {
  const o = r.messages[r.messages.length - 1];
  if (!(e === q.Partial || e === q.Answer) || (o == null ? void 0 : o.role) !== "assistant")
    return;
  const { content: c, sequence: a } = t;
  e === q.Partial ? n[a] = c : n.answer = c;
  const i = tt(n);
  (o.content !== i || e === q.Answer) && (o.content = i, s == null || s([...r.messages], e));
}
function nt(e, t, n, r, s) {
  let o = {};
  return {
    clearQueue: () => o = {},
    onMessage: (c, a) => {
      var i, d;
      if ("content" in a)
        rt(c, a, o, t, n.callbacks.onNewMessage), c === q.Answer && e.track("agent-message-received", {
          messages: t.messages.length,
          mode: t.chatMode
        });
      else {
        const l = P, y = [l.StreamVideoDone, l.StreamVideoError, l.StreamVideoRejected], M = [l.StreamFailed, l.StreamVideoError, l.StreamVideoRejected], j = qe(a, r, { mode: t.chatMode });
        if (c = c, c === l.StreamVideoCreated)
          e.linkTrack("agent-video", j, l.StreamVideoCreated, ["start"]);
        else if (y.includes(c)) {
          const b = c.split("/")[1];
          M.includes(c) ? e.track("agent-video", { ...j, event: b }) : e.linkTrack("agent-video", { ...j, event: b }, c, ["done"]);
        }
        M.includes(c) && ((d = (i = n.callbacks).onError) == null || d.call(i, new Error(`Stream failed with event ${c}`), { data: a })), a.event === l.StreamDone && s();
      }
    }
  };
}
function at(e, t, n, r) {
  const s = ge(e, `${t}/agents/${n}`, r);
  return {
    createStream(o) {
      return s.post("/streams", o);
    },
    startConnection(o, c, a) {
      return s.post(`/streams/${o}/sdp`, {
        session_id: a,
        answer: c
      });
    },
    addIceCandidate(o, c, a) {
      return s.post(`/streams/${o}/ice`, {
        session_id: a,
        ...c
      });
    },
    sendStreamRequest(o, c, a) {
      return s.post(`/streams/${o}`, {
        session_id: c,
        ...a
      });
    },
    close(o, c) {
      return s.delete(`/streams/${o}`, { session_id: c });
    }
  };
}
const it = (e, t) => (n, r) => e && console.log(`[${t}] ${n}`, r ?? "");
function st(e, t, n) {
  const r = (t.timestamp - e.timestamp) / 1e3;
  return {
    duration: r,
    bytesReceived: t.bytesReceived - e.bytesReceived,
    bitrate: Math.round((t.bytesReceived - e.bytesReceived) * 8 / r),
    packetsReceived: t.packetsReceived - e.packetsReceived,
    packetsLost: t.packetsLost - e.packetsLost,
    framesDropped: t.framesDropped - e.framesDropped,
    framesDecoded: t.framesDecoded - e.framesDecoded,
    jitter: t.jitter,
    avgJitterDelayInInterval: (t.jitterBufferDelay - e.jitterBufferDelay) / (t.jitterBufferEmittedCount - e.jitterBufferEmittedCount),
    jitterBufferEmittedCount: t.jitterBufferEmittedCount - e.jitterBufferEmittedCount,
    jitterBufferDelay: (t.jitterBufferDelay - e.jitterBufferDelay) / r,
    framesPerSecond: t.framesPerSecond,
    freezeCount: t.freezeCount - e.freezeCount,
    freezeDuration: t.freezeDuration - e.freezeDuration,
    lowFpsCount: n
  };
}
function ot(e) {
  return e.filter(
    (t) => t.freezeCount > 0 || t.framesPerSecond < 21 || t.framesDropped > 0 || t.packetsLost > 0
  ).map((t) => {
    const { timestamp: n, ...r } = t, s = [];
    return t.freezeCount > 0 && s.push("freeze"), t.framesPerSecond < 21 && s.push("low fps"), t.framesDropped > 0 && s.push("frames dropped"), t.packetsLost > 0 && s.push("packet loss"), {
      ...r,
      causes: s
    };
  });
}
function ct(e) {
  let t = "", n = 0;
  for (const r of e.values())
    if (r && r.type === "codec" && r.mimeType.startsWith("video") && (t = r.mimeType.split("/")[1]), r && r.type === "candidate-pair" && (n = r.currentRoundTripTime), r && r.type === "inbound-rtp" && r.kind === "video")
      return {
        codec: t,
        rtt: n,
        timestamp: r.timestamp,
        bytesReceived: r.bytesReceived,
        packetsReceived: r.packetsReceived,
        packetsLost: r.packetsLost,
        framesDropped: r.framesDropped,
        framesDecoded: r.framesDecoded,
        jitter: r.jitter,
        jitterBufferDelay: r.jitterBufferDelay,
        jitterBufferEmittedCount: r.jitterBufferEmittedCount,
        avgJitterDelayInInterval: r.jitterBufferDelay / r.jitterBufferEmittedCount,
        frameWidth: r.frameWidth,
        frameHeight: r.frameHeight,
        framesPerSecond: r.framesPerSecond,
        freezeCount: r.freezeCount,
        freezeDuration: r.totalFreezesDuration
      };
  return {};
}
function dt(e, t, n) {
  const r = e.map((i, d) => d === 0 ? n ? {
    timestamp: i.timestamp,
    duration: 0,
    rtt: i.rtt,
    bytesReceived: i.bytesReceived - n.bytesReceived,
    bitrate: (i.bytesReceived - n.bytesReceived) * 8 / (t / 1e3),
    packetsReceived: i.packetsReceived - n.packetsReceived,
    packetsLost: i.packetsLost - n.packetsLost,
    framesDropped: i.framesDropped - n.framesDropped,
    framesDecoded: i.framesDecoded - n.framesDecoded,
    jitter: i.jitter,
    jitterBufferDelay: i.jitterBufferDelay - n.jitterBufferDelay,
    jitterBufferEmittedCount: i.jitterBufferEmittedCount - n.jitterBufferEmittedCount,
    avgJitterDelayInInterval: (i.jitterBufferDelay - n.jitterBufferDelay) / (i.jitterBufferEmittedCount - n.jitterBufferEmittedCount),
    framesPerSecond: i.framesPerSecond,
    freezeCount: i.freezeCount - n.freezeCount,
    freezeDuration: i.freezeDuration - n.freezeDuration
  } : {
    timestamp: i.timestamp,
    rtt: i.rtt,
    duration: 0,
    bytesReceived: i.bytesReceived,
    bitrate: i.bytesReceived * 8 / (t / 1e3),
    packetsReceived: i.packetsReceived,
    packetsLost: i.packetsLost,
    framesDropped: i.framesDropped,
    framesDecoded: i.framesDecoded,
    jitter: i.jitter,
    jitterBufferDelay: i.jitterBufferDelay,
    jitterBufferEmittedCount: i.jitterBufferEmittedCount,
    avgJitterDelayInInterval: i.jitterBufferDelay / i.jitterBufferEmittedCount,
    framesPerSecond: i.framesPerSecond,
    freezeCount: i.freezeCount,
    freezeDuration: i.freezeDuration
  } : {
    timestamp: i.timestamp,
    duration: t * d / 1e3,
    rtt: i.rtt,
    bytesReceived: i.bytesReceived - e[d - 1].bytesReceived,
    bitrate: (i.bytesReceived - e[d - 1].bytesReceived) * 8 / (t / 1e3),
    packetsReceived: i.packetsReceived - e[d - 1].packetsReceived,
    packetsLost: i.packetsLost - e[d - 1].packetsLost,
    framesDropped: i.framesDropped - e[d - 1].framesDropped,
    framesDecoded: i.framesDecoded - e[d - 1].framesDecoded,
    jitter: i.jitter,
    jitterBufferDelay: i.jitterBufferDelay - e[d - 1].jitterBufferDelay,
    jitterBufferEmittedCount: i.jitterBufferEmittedCount - e[d - 1].jitterBufferEmittedCount,
    avgJitterDelayInInterval: (i.jitterBufferDelay - e[d - 1].jitterBufferDelay) / (i.jitterBufferEmittedCount - e[d - 1].jitterBufferEmittedCount),
    framesPerSecond: i.framesPerSecond,
    freezeCount: i.freezeCount - e[d - 1].freezeCount,
    freezeDuration: i.freezeDuration - e[d - 1].freezeDuration
  }), s = ot(r), o = s.reduce((i, d) => i + (d.causes.includes("low fps") ? 1 : 0), 0), c = r.filter((i) => !!i.avgJitterDelayInInterval).map((i) => i.avgJitterDelayInInterval), a = r.filter((i) => !!i.rtt).map((i) => i.rtt);
  return {
    webRTCStats: {
      anomalies: s,
      minRtt: Math.min(...a),
      avgRtt: se(a),
      maxRtt: Math.max(...a),
      aggregateReport: st(e[0], e[e.length - 1], o),
      minJitterDelayInInterval: Math.min(...c),
      maxJitterDelayInInterval: Math.max(...c),
      avgJitterDelayInInterval: se(c)
    },
    codec: e[0].codec,
    resolution: `${e[0].frameWidth}x${e[0].frameHeight}`
  };
}
const ie = 100, lt = Math.max(Math.ceil(400 / ie), 1), ut = 0.25, ft = 0.28;
function mt() {
  let e = 0, t, n, r = 0;
  return (s) => {
    for (const o of s.values())
      if (o && o.type === "inbound-rtp" && o.kind === "video") {
        const c = o.jitterBufferDelay, a = o.jitterBufferEmittedCount;
        if (n && a > n) {
          const l = c - t, y = a - n;
          r = l / y;
        }
        t = c, n = a;
        const i = o.framesDecoded, d = i - e > 0;
        return e = i, { isReceiving: d, avgJitterDelayInInterval: r, freezeCount: o.freezeCount };
      }
    return { isReceiving: !1, avgJitterDelayInInterval: r };
  };
}
function gt(e, t, n, r, s, o = !1) {
  let c = [], a, i = 0, d = !1, l = G.Unknown, y = G.Unknown, M = 0, j = 0;
  const b = mt();
  return setInterval(async () => {
    const z = await e.getStats(), { isReceiving: U, avgJitterDelayInInterval: W, freezeCount: C } = b(z), K = ct(z);
    if (U)
      i = 0, M = C - j, y = W < ut ? G.Strong : W > ft && M > 1 ? G.Weak : l, y !== l && (s == null || s(y), l = y, j += M, M = 0), d || (r == null || r(w.Start), a = c[c.length - 1], c = [], d = !0), c.push(K);
    else if (d && (i++, i >= lt)) {
      const u = dt(c, ie, a);
      r == null || r(w.Stop, u), t() || n(), j = C, d = !1;
    }
  }, ie);
}
const ht = (window.RTCPeerConnection || window.webkitRTCPeerConnection || window.mozRTCPeerConnection).bind(window);
function oe(e) {
  switch (e) {
    case "connected":
      return R.Connected;
    case "checking":
      return R.Connecting;
    case "failed":
      return R.Fail;
    case "new":
      return R.New;
    case "closed":
      return R.Closed;
    case "disconnected":
      return R.Disconnected;
    case "completed":
      return R.Completed;
    default:
      return R.New;
  }
}
const wt = (e) => (t) => {
  const [n, r = ""] = t.split(/:(.+)/);
  try {
    const s = JSON.parse(r);
    return e("parsed data channel message", { subject: n, data: s }), { subject: n, data: s };
  } catch (s) {
    return e("Failed to parse data channel message, returning data as string", { subject: n, rawData: r, error: s }), { subject: n, data: r };
  }
};
function pt({
  statsSignal: e,
  dataChannelSignal: t,
  onVideoStateChange: n,
  report: r
}) {
  e === w.Start && t === w.Start ? n == null || n(w.Start) : e === w.Stop && t === w.Stop && (n == null || n(w.Stop, r));
}
function yt({
  statsSignal: e,
  dataChannelSignal: t,
  onVideoStateChange: n,
  onAgentActivityStateChange: r,
  report: s
}) {
  e === w.Start ? n == null || n(w.Start) : e === w.Stop && (n == null || n(w.Stop, s)), t === w.Start ? r == null || r(O.Talking) : t === w.Stop && (r == null || r(O.Idle));
}
function ce({
  statsSignal: e,
  dataChannelSignal: t,
  onVideoStateChange: n,
  onAgentActivityStateChange: r,
  streamType: s,
  report: o
}) {
  s === J.Legacy ? pt({ statsSignal: e, dataChannelSignal: t, onVideoStateChange: n, report: o }) : s === J.Fluent && yt({
    statsSignal: e,
    dataChannelSignal: t,
    onVideoStateChange: n,
    onAgentActivityStateChange: r,
    report: o
  });
}
async function vt(e, t, { debug: n = !1, callbacks: r, auth: s, baseURL: o = ee, analytics: c }) {
  var Y;
  const a = it(n, "WebRTCStreamingManager"), i = wt(a);
  let d = !1, l = !1, y = w.Stop, M = w.Stop;
  const { startConnection: j, sendStreamRequest: b, close: z, createStream: U, addIceCandidate: W } = at(
    s,
    o,
    e,
    r.onError
  ), {
    id: C,
    offer: K,
    ice_servers: u,
    session_id: h,
    fluent: p,
    interrupt_enabled: _,
    triggers_enabled: v
  } = await U(t);
  (Y = r.onStreamCreated) == null || Y.call(r, { stream_id: C, session_id: h, agent_id: e });
  const f = new ht({ iceServers: u }), S = f.createDataChannel("JanusDataChannel");
  if (!h)
    throw new Error("Could not create session_id");
  const T = p ? J.Fluent : J.Legacy;
  c.enrich({
    "stream-type": T
  });
  const L = t.stream_warmup && !p, D = () => d, I = () => {
    var m;
    d = !0, l && ((m = r.onConnectionStateChange) == null || m.call(r, R.Connected));
  }, k = gt(
    f,
    D,
    I,
    (m, g) => ce({
      statsSignal: M = m,
      dataChannelSignal: T === J.Legacy ? y : void 0,
      onVideoStateChange: r.onVideoStateChange,
      onAgentActivityStateChange: r.onAgentActivityStateChange,
      report: g,
      streamType: T
    }),
    (m) => {
      var g;
      return (g = r.onConnectivityStateChange) == null ? void 0 : g.call(r, m);
    },
    L
  );
  f.onicecandidate = (m) => {
    var g;
    a("peerConnection.onicecandidate", m);
    try {
      m.candidate && m.candidate.sdpMid && m.candidate.sdpMLineIndex !== null ? W(
        C,
        {
          candidate: m.candidate.candidate,
          sdpMid: m.candidate.sdpMid,
          sdpMLineIndex: m.candidate.sdpMLineIndex
        },
        h
      ) : W(C, { candidate: null }, h);
    } catch (A) {
      (g = r.onError) == null || g.call(r, A, { streamId: C });
    }
  }, S.onopen = () => {
    l = !0, (!L || d) && I();
  };
  const x = (m) => {
    var g;
    (g = r.onVideoIdChange) == null || g.call(r, m);
  };
  function B(m, g) {
    if (m === P.StreamStarted && typeof g == "object" && "metadata" in g) {
      const A = g.metadata;
      x(A.videoId);
    }
    m === P.StreamDone && x(null), y = m === P.StreamStarted ? w.Start : w.Stop, ce({
      statsSignal: T === J.Legacy ? M : void 0,
      dataChannelSignal: y,
      onVideoStateChange: r.onVideoStateChange,
      onAgentActivityStateChange: r.onAgentActivityStateChange,
      streamType: T
    });
  }
  function F(m, g) {
    const A = typeof g == "string" ? g : g == null ? void 0 : g.metadata;
    A && c.enrich({ streamMetadata: A }), c.track("agent-chat", { event: "ready" });
  }
  const N = {
    [P.StreamStarted]: B,
    [P.StreamDone]: B,
    [P.StreamReady]: F
  };
  S.onmessage = (m) => {
    var Q;
    const { subject: g, data: A } = i(m.data);
    (Q = N[g]) == null || Q.call(N, g, A);
  }, f.oniceconnectionstatechange = () => {
    var g;
    a("peerConnection.oniceconnectionstatechange => " + f.iceConnectionState);
    const m = oe(f.iceConnectionState);
    m !== R.Connected && ((g = r.onConnectionStateChange) == null || g.call(r, m));
  }, f.ontrack = (m) => {
    var g;
    a("peerConnection.ontrack", m), (g = r.onSrcObjectReady) == null || g.call(r, m.streams[0]);
  }, await f.setRemoteDescription(K), a("set remote description OK");
  const X = await f.createAnswer();
  return a("create answer OK"), await f.setLocalDescription(X), a("set local description OK"), await j(C, X, h), a("start connection OK"), {
    /**
     * Method to send request to server to get clip or talk depend on you payload
     * @param payload
     */
    speak(m) {
      return b(C, h, m);
    },
    /**
     * Method to close RTC connection
     */
    async disconnect() {
      var m;
      if (C) {
        const g = oe(f.iceConnectionState);
        if (f) {
          if (g === R.New) {
            clearInterval(k);
            return;
          }
          f.close(), f.oniceconnectionstatechange = null, f.onnegotiationneeded = null, f.onicecandidate = null, f.ontrack = null;
        }
        try {
          g === R.Connected && await z(C, h).catch((A) => {
          });
        } catch (A) {
          a("Error on close stream connection", A);
        }
        (m = r.onAgentActivityStateChange) == null || m.call(r, O.Idle), clearInterval(k);
      }
    },
    /**
     * Method to send data channel messages to the server
     */
    sendDataChannelMessage(m) {
      var g, A;
      if (!d || S.readyState !== "open") {
        a("Data channel is not ready for sending messages"), (g = r.onError) == null || g.call(r, new Error("Data channel is not ready for sending messages"), {
          streamId: C
        });
        return;
      }
      try {
        S.send(m);
      } catch (Q) {
        a("Error sending data channel message", Q), (A = r.onError) == null || A.call(r, Q, { streamId: C });
      }
    },
    /**
     * Session identifier information, should be returned in the body of all streaming requests
     */
    sessionId: h,
    /**
     * Id of current RTC stream
     */
    streamId: C,
    streamType: T,
    interruptAvailable: _ ?? !1,
    triggersAvailable: v ?? !1
  };
}
const kt = (e) => e.presenter.type === de.Expressive;
async function Dt(e, t, n) {
  const r = e.id;
  return kt(e) ? {} : vt(r, t, n);
}
function Ct(e) {
  const { streamOptions: t } = e ?? {};
  return {
    output_resolution: t == null ? void 0 : t.outputResolution,
    session_timeout: t == null ? void 0 : t.sessionTimeout,
    stream_warmup: t == null ? void 0 : t.streamWarmup,
    compatibility_mode: t == null ? void 0 : t.compatibilityMode,
    fluent: t == null ? void 0 : t.fluent
  };
}
function Rt(e, t, n, r, s) {
  s === J.Fluent ? St(e, t, n, r, s) : Et(e, t, n, r, s);
}
function St(e, t, n, r, s) {
  e === w.Start ? r.track("stream-session", { event: "start", "stream-type": s }) : e === w.Stop && r.track("stream-session", {
    event: "stop",
    is_greenscreen: t.presenter.type === "clip" && t.presenter.is_greenscreen,
    background: t.presenter.type === "clip" && t.presenter.background,
    "stream-type": s,
    ...n
  });
}
function It(e, t, n, r) {
  $.get() <= 0 || (e === w.Start ? n.linkTrack(
    "agent-video",
    { event: "start", latency: $.get(!0), "stream-type": r },
    "start",
    [P.StreamVideoCreated]
  ) : e === w.Stop && n.linkTrack(
    "agent-video",
    {
      event: "stop",
      is_greenscreen: t.presenter.type === "clip" && t.presenter.is_greenscreen,
      background: t.presenter.type === "clip" && t.presenter.background,
      "stream-type": r
    },
    "done",
    [P.StreamVideoDone]
  ));
}
function Et(e, t, n, r, s) {
  $.get() <= 0 || (e === w.Start ? r.linkTrack(
    "agent-video",
    { event: "start", latency: $.get(!0), "stream-type": s },
    "start",
    [P.StreamVideoCreated]
  ) : e === w.Stop && r.linkTrack(
    "agent-video",
    {
      event: "stop",
      is_greenscreen: t.presenter.type === "clip" && t.presenter.is_greenscreen,
      background: t.presenter.type === "clip" && t.presenter.background,
      "stream-type": s,
      ...n
    },
    "done",
    [P.StreamVideoDone]
  ));
}
function Mt(e, t, n) {
  return $.reset(), new Promise(async (r, s) => {
    try {
      let o;
      o = await Dt(e, Ct(t), {
        ...t,
        analytics: n,
        callbacks: {
          ...t.callbacks,
          onConnectionStateChange: (c) => {
            var a, i;
            (i = (a = t.callbacks).onConnectionStateChange) == null || i.call(a, c), c === R.Connected && r(o);
          },
          onVideoStateChange: (c, a) => {
            var i, d;
            (d = (i = t.callbacks).onVideoStateChange) == null || d.call(i, c), Rt(
              c,
              e,
              a,
              n,
              o.streamType
            );
          },
          onAgentActivityStateChange: (c) => {
            var a, i;
            (i = (a = t.callbacks).onAgentActivityStateChange) == null || i.call(a, c), c === O.Talking ? ae.update() : ae.reset(), It(
              c === O.Talking ? w.Start : w.Stop,
              e,
              n,
              o.streamType
            );
          }
        }
      });
    } catch (o) {
      s(o);
    }
  });
}
async function _t(e, t, n, r, s) {
  var y, M, j, b;
  const o = ve(e, n, r, t.mode, t.persistentChat, s), c = Mt(e, t, r), [a, i] = await Promise.all([o, c]), { chat: d, chatMode: l } = a;
  return l && l !== t.mode && (t.mode = l, (M = (y = t.callbacks).onModeChange) == null || M.call(y, l), l !== E.Functional) ? ((b = (j = t.callbacks).onError) == null || b.call(j, new Re(l)), i == null || i.disconnect(), { chat: d }) : { chat: d, streamingManager: i };
}
async function At(e, t) {
  var W, C, K;
  let n = !0, r = null;
  const s = t.mixpanelKey || ze, o = t.wsURL || xe, c = t.baseURL || ee, a = {
    messages: [],
    chatMode: t.mode || E.Functional
  }, i = Oe({
    token: s,
    agentId: e,
    isEnabled: t.enableAnalitics,
    distinctId: t.distinctId,
    mixpanelAdditionalProperties: t.mixpanelAdditionalProperties
  });
  i.track("agent-sdk", { event: "init" });
  const d = he(t.auth, c, t.callbacks.onError), l = await d.getById(e);
  i.enrich(Ke(l));
  const { onMessage: y, clearQueue: M } = nt(
    i,
    a,
    t,
    l,
    () => {
      var u;
      return (u = a.socketManager) == null ? void 0 : u.disconnect();
    }
  );
  a.messages = Xe(t.initialMessages), (C = (W = t.callbacks).onNewMessage) == null || C.call(W, [...a.messages], "answer");
  const j = (u) => {
    r = u;
  };
  i.track("agent-sdk", { event: "loaded", ...Ue(l) });
  async function b(u) {
    var S, T, L, D, I, k, x;
    (T = (S = t.callbacks).onConnectionStateChange) == null || T.call(S, R.Connecting), $.reset(), u && !n && (delete a.chat, (D = (L = t.callbacks).onNewMessage) == null || D.call(L, [...a.messages], "answer"));
    const h = t.mode === E.DirectPlayback ? Promise.resolve(void 0) : et(t.auth, o, { onMessage: y, onError: t.callbacks.onError }), p = ne(
      () => _t(
        l,
        { ...t, callbacks: { ...t.callbacks, onVideoIdChange: j } },
        d,
        i,
        a.chat
      ),
      {
        limit: 3,
        timeout: Be,
        timeoutErrorMessage: "Timeout initializing the stream",
        // Retry on all errors except for connection errors and rate limit errors, these are already handled in client level.
        shouldRetryFn: (B) => (B == null ? void 0 : B.message) !== "Could not connect" && B.status !== 429,
        delayMs: 1e3
      }
    ).catch((B) => {
      var F, N;
      throw U(E.Maintenance), (N = (F = t.callbacks).onConnectionStateChange) == null || N.call(F, R.Fail), B;
    }), [_, { streamingManager: v, chat: f }] = await Promise.all([h, p]);
    f && f.id !== ((I = a.chat) == null ? void 0 : I.id) && ((x = (k = t.callbacks).onNewChat) == null || x.call(k, f.id)), a.streamingManager = v, a.socketManager = _, a.chat = f, n = !1, i.enrich({
      chatId: f == null ? void 0 : f.id,
      streamId: v == null ? void 0 : v.streamId,
      mode: a.chatMode
    }), U((f == null ? void 0 : f.chat_mode) ?? t.mode ?? E.Functional);
  }
  async function z() {
    var u, h, p, _;
    (u = a.socketManager) == null || u.disconnect(), await ((h = a.streamingManager) == null ? void 0 : h.disconnect()), delete a.streamingManager, delete a.socketManager, (_ = (p = t.callbacks).onConnectionStateChange) == null || _.call(p, R.Disconnected);
  }
  async function U(u) {
    var h, p;
    u !== a.chatMode && (i.track("agent-mode-change", { mode: u }), a.chatMode = u, a.chatMode !== E.Functional && await z(), (p = (h = t.callbacks).onModeChange) == null || p.call(h, u));
  }
  return {
    agent: l,
    getStreamType: () => {
      var u;
      return (u = a.streamingManager) == null ? void 0 : u.streamType;
    },
    getIsInterruptAvailable: () => {
      var u;
      return ((u = a.streamingManager) == null ? void 0 : u.interruptAvailable) ?? !1;
    },
    getIsTriggersAvailable: () => {
      var u;
      return ((u = a.streamingManager) == null ? void 0 : u.triggersAvailable) ?? !1;
    },
    starterMessages: ((K = l.knowledge) == null ? void 0 : K.starter_message) || [],
    getSTTToken: () => d.getSTTToken(l.id),
    changeMode: U,
    enrichAnalytics: i.enrich,
    async connect() {
      await b(!0), i.track("agent-chat", {
        event: "connect",
        mode: a.chatMode
      });
    },
    async reconnect() {
      await z(), await b(!1), i.track("agent-chat", {
        event: "reconnect",
        mode: a.chatMode
      });
    },
    async disconnect() {
      await z(), i.track("agent-chat", {
        event: "disconnect",
        mode: a.chatMode
      });
    },
    async chat(u) {
      var v, f, S, T, L;
      const h = () => {
        if (ue(t.mode))
          throw new H(`${t.mode} is enabled, chat is disabled`);
        if (u.length >= 800)
          throw new H("Message cannot be more than 800 characters");
        if (u.length === 0)
          throw new H("Message cannot be empty");
        if (a.chatMode === E.Maintenance)
          throw new H("Chat is in maintenance mode");
        if (![E.TextOnly, E.Playground].includes(a.chatMode)) {
          if (!a.streamingManager)
            throw new H("Streaming manager is not initialized");
          if (!a.chat)
            throw new H("Chat is not initialized");
        }
      }, p = async () => {
        var D, I;
        if (!a.chat) {
          const k = await ve(
            l,
            d,
            i,
            a.chatMode,
            t.persistentChat
          );
          if (!k.chat)
            throw new Ce(a.chatMode, !!t.persistentChat);
          a.chat = k.chat, (I = (D = t.callbacks).onNewChat) == null || I.call(D, a.chat.id);
        }
        return a.chat.id;
      }, _ = async (D, I) => ne(
        () => {
          var k, x;
          return d.chat(
            l.id,
            I,
            {
              chatMode: a.chatMode,
              streamId: (k = a.streamingManager) == null ? void 0 : k.streamId,
              sessionId: (x = a.streamingManager) == null ? void 0 : x.sessionId,
              messages: D.map(({ matches: B, ...F }) => F)
            },
            {
              ...ye(a.chatMode),
              skipErrorHandler: !0
            }
          );
        },
        {
          limit: 2,
          shouldRetryFn: (k) => {
            var F, N, X, Y;
            const x = (F = k == null ? void 0 : k.message) == null ? void 0 : F.includes("missing or invalid session_id");
            return !((N = k == null ? void 0 : k.message) == null ? void 0 : N.includes("Stream Error")) && !x ? ((Y = (X = t.callbacks).onError) == null || Y.call(X, k), !1) : !0;
          },
          onRetry: async () => {
            await z(), await b(!1);
          }
        }
      );
      try {
        M(), h(), a.messages.push({
          id: V(),
          role: "user",
          content: u,
          created_at: new Date($.update()).toISOString()
        }), (f = (v = t.callbacks).onNewMessage) == null || f.call(v, [...a.messages], "user");
        const D = await p(), I = await _([...a.messages], D);
        return a.messages.push({
          id: V(),
          role: "assistant",
          content: I.result || "",
          created_at: (/* @__PURE__ */ new Date()).toISOString(),
          context: I.context,
          matches: I.matches
        }), i.track("agent-message-send", {
          event: "success",
          messages: a.messages.length + 1
        }), I.result && ((T = (S = t.callbacks).onNewMessage) == null || T.call(S, [...a.messages], "answer"), i.track("agent-message-received", {
          latency: $.get(!0),
          messages: a.messages.length
        })), I;
      } catch (D) {
        throw ((L = a.messages[a.messages.length - 1]) == null ? void 0 : L.role) === "assistant" && a.messages.pop(), i.track("agent-message-send", {
          event: "error",
          messages: a.messages.length
        }), D;
      }
    },
    rate(u, h, p) {
      var f, S, T, L;
      const _ = a.messages.find((D) => D.id === u);
      if (a.chat) {
        if (!_)
          throw new Error("Message not found");
      } else throw new Error("Chat is not initialized");
      const v = ((f = _.matches) == null ? void 0 : f.map((D) => [D.document_id, D.id])) ?? [];
      return i.track("agent-rate", {
        event: p ? "update" : "create",
        thumb: h === 1 ? "up" : "down",
        knowledge_id: ((S = l.knowledge) == null ? void 0 : S.id) ?? "",
        matches: v,
        score: h
      }), p ? d.updateRating(l.id, a.chat.id, p, {
        knowledge_id: ((T = l.knowledge) == null ? void 0 : T.id) ?? "",
        message_id: u,
        matches: v,
        score: h
      }) : d.createRating(l.id, a.chat.id, {
        knowledge_id: ((L = l.knowledge) == null ? void 0 : L.id) ?? "",
        message_id: u,
        matches: v,
        score: h
      });
    },
    deleteRate(u) {
      if (!a.chat)
        throw new Error("Chat is not initialized");
      return i.track("agent-rate-delete", { type: "text" }), d.deleteRating(l.id, a.chat.id, u);
    },
    async speak(u) {
      var v, f, S;
      function h() {
        if (typeof u == "string") {
          if (!l.presenter.voice)
            throw new Error("Presenter voice is not initialized");
          return {
            type: "text",
            provider: l.presenter.voice,
            input: u,
            ssml: !1
          };
        }
        if (u.type === "text" && !u.provider) {
          if (!l.presenter.voice)
            throw new Error("Presenter voice is not initialized");
          return {
            type: "text",
            provider: l.presenter.voice,
            input: u.input,
            ssml: u.ssml
          };
        }
        return u;
      }
      const p = h();
      if (i.track("agent-speak", p), $.update(), a.messages && p.type === "text" && (a.messages.push({
        id: V(),
        role: "assistant",
        content: p.input,
        created_at: new Date($.get(!0)).toISOString()
      }), (f = (v = t.callbacks).onNewMessage) == null || f.call(v, [...a.messages], "answer")), Fe(a.chatMode))
        return {
          duration: 0,
          video_id: "",
          status: "success"
        };
      if (!a.streamingManager)
        throw new Error("Please connect to the agent first");
      return a.streamingManager.speak({
        script: p,
        metadata: { chat_id: (S = a.chat) == null ? void 0 : S.id, agent_id: l.id }
      });
    },
    async interrupt({ type: u }) {
      var p, _, v;
      Ye(a.streamingManager, (p = a.streamingManager) == null ? void 0 : p.streamType, r);
      const h = a.messages[a.messages.length - 1];
      i.track("agent-video-interrupt", {
        type: u || "click",
        video_duration_to_interrupt: ae.get(!0),
        message_duration_to_interrupt: $.get(!0)
      }), h.interrupted = !0, (v = (_ = t.callbacks).onNewMessage) == null || v.call(_, [...a.messages], "answer"), Qe(a.streamingManager, r);
    }
  };
}
function bt(e, t, n) {
  const { getById: r } = he(t, n || ee);
  return r(e);
}
export {
  O as AgentActivityState,
  Me as AgentStatus,
  Ce as ChatCreationFailed,
  E as ChatMode,
  Re as ChatModeDowngraded,
  q as ChatProgress,
  R as ConnectionState,
  G as ConnectivityState,
  Ae as DocumentType,
  je as KnowledgeType,
  Ee as PlanGroup,
  Pe as Providers,
  _e as RateState,
  P as StreamEvents,
  J as StreamType,
  w as StreamingState,
  Te as Subject,
  be as Transport,
  Ie as UserPlan,
  H as ValidationError,
  de as VideoType,
  Le as VoiceAccess,
  Se as WsError,
  At as createAgentManager,
  bt as getAgent,
  jt as mapVideoType
};
